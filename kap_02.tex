\chapter{Microservice Architektur als Weg robuste und skalierbare Anwendungen zu entwickeln}
``Microservice Architektur'' beschreibt einen Stil der Softwareentwicklung, der vor Allem durch die Trennung einer großen Gesamtanwendung, in kleinere, separate Teile gekennzeichnet ist.~\footcite[vgl.][Seite 2]{newman2015building}
Entscheidend für die Microservice Architektur ist im wesentlichen die Abgrenzung zur monolithischen Anwendungsentwicklung.

\section{Microservices als Werkzeug zum Management von Komplexität}
Monolithische Anwendungen bestehen im wesentlichen aus einer einzelnen Einheit~\footcite[vgl.][]{Fowler:Intro}. In einer klassischen drei-Schichten Anwendung (Frontend, Backend, Persistence Layer)~\footcite[vgl.][]{MSDN:TTA} bietet es sich an, die gesamte Logik in einer Anwendung zu verwalten. Dies ist auch der Standardaufbau der meisten Webframeworks. Es gibt eine Schnittstelle zwischen der clientseitigen und der serverseitigen Anwendung, ebenso wie eine Schnittstelle zwischen der serverseitigen Anwendung und der Datenbank. Unabhängig wie unübersichtlich ein System mit zunehmender Größe wird, das zusammenhalten dieser Anwendungsteile ist der default Weg. Der Hauptgrund für die Entstehung schwer zu handhabender Monolithen ist somit meistens das Wachstum mit der Zeit~\footcite[vgl.][]{infaktuell}.

Anstatt einer großen Anwendung, deren einzelne Teile gemeinsam deployt werden, in einem gemeinsamen repository liegen und auf der Ebene der genutzten Programmiersprache kommunizieren, wird bei der Microservice Architektur die Gesamtanwendung hingegen in einzelne Teilanwendungen aufgesplittet. Diese liegen in separaten Repositories, können getrennt voneinander deployt werden und kommunizieren über externe Schnittstellen. Diese separaten Teilanwendungen sind meist anhand von Aufgabengebieten getrennt und identifiziert. Die Trennung nach Single Responsibility Principle~\footcite[vgl.][Seite 108]{Martin:SRP} wird hier von der Ebene des Codes in die Ebene der Gesamtarchitektur gehoben.

Die Aufteilung einer monolithischen Gesamtanwendung in kleinere Services ist keineswegs ein Allheilmittel für alle Probleme. Microservice Architektur bringt seine ganz eigenen Herausforderungen mit sich. Microservice Architektur bringt demnach vor allem Unterschiede mit sich. Die Frage ob sich diese positiv oder negativ auswirken, hängt ganz individuell von der bestehenden Anwendung, dem Entwicklerteam und den vorhandenen Resourcen ab.

\section{Herausforderungen und Potentiale von Microservices}
Durch diese Aufteilung in einzelne Teilanwendungen werden jedoch Komplexitäten keineswegs reduziert. Der entstehende Overhead zur Verwaltung verschiedener Codebases, standardisierter Schnittstellen, separater Deploys und separatem Monitoring erzeugt zunächst einmal einen größeren Aufwand. Stattdessen bieten Microservices jedoch viele Optimierungsmöglichkeiten. Klar strukturierte Codebases verschaffen einen besseren Überblick, sodass sich Entwickler leichter in ein Aufgabe einarbeiten können ohne sich durch irrelevante Codeteile arbeiten zu müssen. Ähnlich wie das Single Responsibility Principle auf Methoden- oder Klassenebene gilt, so gilt es auch auf Service Ebene. Getrennte, klar strukturierte Codeteile erhöhen die Wiederverwendbarkeit, erleichtern die Einarbeitung und das Management des Codes. Ebenso können Änderungen leichter eingearbeitet werden, da die Chance Seiteneffekten reduziert ist. Komplexitäten werden demnach nicht per sé reduziert, sie werden jedoch aufgetrennt und verschoben. Somit werden sie leichter zu handhaben.

So lassen sich zum Einen kleinere, autonome Anwendungsteile aus Entwicklersicht besser verwalten. Die einzelnen Anwendungsteile müssen aber über eine standardisierte Schnittstelle kommunizieren. Diese Aufrufe, die in der Regel über das Intra- oder Internet stattfinden sind in der Regel aufwändiger als simple Code Calls. Wie diese API calls stattfinden ist nicht zwangsläufig vorgeschrieben [WAS FUR MOGLICHKEITEN GIBT ES]
Wie bereits erläutert, ist die Microservice Architektur von der ``klassischen'' monolithischen Anwendungsentwicklung erst einmal grundlegend verschieden. Diese Unterschiede bilden Vor- und Nachteile der Microservice Architektur.

\section{Der Weg zum Microservice}
Wie eine Anwendung, bestehend aus verschiedenen Microservices, entsteht und entwickelt wird , hängt von der konkreten Ausgangssituation ab. Hier kann man in verschiedenen Situationen unterscheiden:

1. Es neuer Anwendungsteil soll entwickelt werden. Die Aufgaben des neuen Anwendungsteils sind weder in der bestehenden Anwendung, noch extern vorhanden. Es wird neuer Code geschrieben und in die bestehende Anwendung integriert.

2. Ein bereits bestehender Anwendungsteil soll von Grund auf neu geschrieben werden. Bestehender Code wird ersetzt und der neue Code in die bestehende Anwendung integriert.

3. Ein bereits bestehender Anwendungsteil soll zu einem Microservice umgebaut werden. Der bestehende Code soll nicht ersetzt, sondern lediglich verschoben werden. Die Schnittstellen zum bestehenden Code müssen erneuert werden.

Zwar unterscheiden sich die drei aufgeführten Ausgangssituationen im Endprodukt nicht zwangsläufig. In der Entwicklung des Microservices muss aber grundlegend anders vorgegangen werden. 

Im ersten Fall kann der neue Anwendungsteil nach idealen und neuen Vorstellungen entwickelt werden. Zwar muss auch hier eine Integration zum bestehenden Code geschaffen werden, es gibt aber keine bisherige Implementation die beachtet werden muss. Die Entwickler haben die freie Wahl, die bestmögliche Integrationsform zu wählen.

Der zweite und dritte Fall unterscheiden sich nicht grundlegend. Die bestehende Schnittstelle zur betroffenen Funktion muss komplett überarbeitet werden. Sowohl in der bestehenden, als auch in der neu entstehenden Anwendung muss diese Schnittstelle geschaffen werden. Auch wenn nur existierender Code verschoben wird muss in der Regel eine komplett neue Schnittstelle geschaffen werden. Wo vorher code calls genutzt wurden, werden nun API calls genutzt. 
Je nach Komplexität und Struktur der Anwendung kann der zweite oder der dritte Fall in der Umsetzung schwieriger sein. Je nach Alter des bestehenden Codes ist eine Neuentwicklung teils ratsam. Da die Umarbeitung ohnehin mit erheblichem Arbeitsaufwand verbunden ist, bietet sich eine Optimierung des bestehenden Codes häufig an. Bei großen, komplexen Legacy Anwendungen ist dies in der Praxis aber häufig nicht ratsam.
