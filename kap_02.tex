\chapter{Microservice Architektur als Weg robuste und skalierbare Anwendungen zu entwickeln}
``Microservice Architektur'' beschreibt einen Stil der Softwareentwicklung, der vor Allem durch die Trennung einer großen Gesamtanwendung, in kleinere, separate Teile gekennzeichnet ist.~\footcite[vgl.][Seite 2]{newman2015building}
Entscheidend für die Microservice Architektur ist im wesentlichen die Abgrenzung zur monolithischen Anwendungsentwicklung.

\section{Microservices als Werkzeug zum Management von Komplexität}
Monolithische Anwendungen bestehen im wesentlichen aus einer einzelnen Einheit.~\footcite[vgl.][]{Fowler:Intro} In einer klassischen drei-Schichten Anwendung (Frontend, Backend, Persistence Layer)~\footcite[vgl.][]{MSDN:TTA} bietet es sich an, die gesamte Logik in einer Anwendung zu verwalten. Dies ist auch der Standardaufbau der meisten Webframeworks. Es gibt eine Schnittstelle zwischen der clientseitigen und der serverseitigen Anwendung, ebenso wie zwischen der serverseitigen Anwendung und der Datenbank. Unabhängig wie unübersichtlich ein System mit zunehmender Größe wird, das zusammenhalten dieser Anwendungsteile ist der default Weg. Schwer zu handhabende, komplexe und große monolithische Anwendungen entstehen häufig dann, wenn bei Wachstum mit der Zeit dieser Aufbau nicht überdacht wird.~\footcite[vgl.][]{infaktuell}

Anstatt einer großen Anwendung, deren einzelne Teile gemeinsam deployt werden, in einem gemeinsamen repository liegen und auf der Ebene der genutzten Programmiersprache kommunizieren, wird bei der Microservice Architektur die Gesamtanwendung hingegen in einzelne Teilanwendungen aufgesplittet. Diese liegen in separaten Repositories, können getrennt voneinander deployt werden und kommunizieren über externe Schnittstellen. Diese separaten Teilanwendungen sind meist anhand von Aufgabengebieten getrennt und identifiziert. Die Trennung nach Single Responsibility Principle~\footcite[vgl.][Seite 108]{Martin:SRP} wird hier von der Ebene des Codes in die Ebene der Gesamtarchitektur gehoben.

Die Aufteilung einer monolithischen Gesamtanwendung in kleinere Services ist jedoch keineswegs ein Allheilmittel für alle Probleme. Microservice Architektur birgt seine ganz eigenen Herausforderungen. Microservice Architektur bringt demnach vor allem Unterschiede mit sich. Die Frage ob sich diese positiv oder negativ auswirken, hängt ganz individuell von der bestehenden Anwendung, dem Entwicklerteam und den vorhandenen Resourcen ab.

Ein Architekturstil, der der Microservice Architektur ähnelt, ist die ``Service-Oriented Architecture''. Aufgrund der ähnlichen Ansätze, die dieser Architekturstil verfolgt, sollte er näher betrachtet werden.
Service-Oriented Architecture (SOA) hat sich ebenfalls entwickelt, um die Probleme großer, monolithischer Anwendungen zu lösen.~\footcite[][Seite 8]{newman2015building} Mit Hilfe von Services, soll wiederverwendbarer Code geschaffen werden, der dann von verschiedenen Endanwendungen genutzt werden kann. Die Kommunikation findet über Netwerke statt und nicht mehr über direkte Aufrufe im Code. Auch SOA soll es einfacher machen Code zu organisieren, zu strukturieren und bei Bedarf zu ersetzen. Warum entsteht nun also der Trend der Microservices, wenn SOA einen ähnlichen Ansatz verfolgt? Ein großes Problem von SOA liegt eigentlich in den damit verbundenen Technologien wie SOAP, vendor middleware und der nicht ausreichend klaren Trennung der Services.~\footcite[][Seite 8]{newman2015building} SOA Services teilen sich z.B. oft Datenbanken, wohingegen dies ein no-go bei Microservices ist. SOA scheint zudem nicht klar genug definiert zu sein.~\footcite[vgl.][]{Fowler:Intro} Daher ist es ratsam einen klarer definierten Begriff, wie den der Microserice Architektur anzustreben.~\footcite[][]{Fowler:Intro}
(FIX THIS IS NOT GOOD AT ALL)

\section{Herausforderungen und Potentiale von Microservices}
Wie jeder Architekturstil bieten auch Microservices sowohl Vorzüge, als auch ganz eigene Kosten.~\footcite[vgl.][]{Fowler:Guide} 
Zum Einen der Punkt separater, klar strukturierter Codebases. Diese verschaffen einen besseren Überblick, sodass sich Entwickler leichter in ein Aufgabe einarbeiten können ohne sich durch irrelevante Codeteile arbeiten zu müssen. Gerade in größeren Teams ist dies von großem Vorteil. Je mehr parallel an voneinander abhängigen Codeteilen gearbeitet wird, desto mehr merge Konflikte entstehen. Auch wenn die eigentlichen Aufgaben komplett voneinander getrennt sind, kommt es häufig zu Konflikten. Je vermischter der Code ist, desto mehr Konflitke enstehen. Ähnlich wie das Single Responsibility Principle auf Methoden- oder Klassenebene gilt, so kann man es auch auf Service Ebene als geltend ansehen. Getrennte, klar strukturierte Codeteile erhöhen die Wiederverwendbarkeit, erleichtern die Einarbeitung und das Management des Codes. Ebenso können Änderungen leichter eingearbeitet werden, da die Chance von Seiteneffekten reduziert ist. Komplexitäten werden demnach nicht per sé reduziert, sie werden jedoch aufgetrennt und verschoben. Somit werden sie leichter zu handhaben.
So lassen sich zum Einen kleinere, autonome Anwendungsteile aus Entwicklersicht besser verwalten. Die einzelnen Anwendungsteile müssen jedoch über eine externe Schnittstelle kommunizieren. Diese Aufrufe, die in der Regel über das Intra- oder Internet stattfinden sind aufwändiger als simple Code Calls. Wie diese API calls stattfinden ist nicht zwangsläufig vorgeschrieben [WAS FUR MOGLICHKEITEN GIBT ES]. Im Allgemeinen gilt jedoch: Verteilte Systeme sind schwieriger zu programmieren, da remote calls langsam und fehleranfälliger sind.~\footcite[vgl.][]{Fowler:Guide}

Die Aufteilung in separate Services kann ebenso das Deployment vereinfachen. Relativ kleine Änderungen können leichter deployt werden, da nicht das ganze System erneut deployt werden muss. Bei großen, komplexen Anwendungen kann dies ein ganz eigenes Risiko bilden. Ist das Deployment einer Anwendung riskoreich, wird im Allgemeinen seltener deployt. Features werden erst später deployt, doch mit wachsenden Unterschieden zwischen Deployments, wächst auch das Risiko von Fehlern.~\footcite[vgl.][Seite 6]{newman2015building}
Separate Deploys von Microservices machen die Versionsverwaltung von diesen jedoch um so wichtiger~\footcite[vgl.][Seite 62]{newman2015building}~\footcite[vgl.][]{Vergleichsartikel}. Breaking Changes können nicht einfach deployt werden und da gleichzeitige Deploys verschiedener, mit einander kommunizierender Services nicht möglich sind, müssen diese Deploys schrittweise und kontrolliert durchgeführt werden: Zunächst muss der Service um eine neue Version erweitert werden, die alte Schnittstelle darf hierbei nicht verändert werden. Meist werden hierzu API Versionen genutzt. So kann die erste Schnittstelle über die URL

\begin{lstlisting}[language=Ruby]
https://meinservice.tld/api/v1/eineRoute
\end{lstlisting}

angesprochen werden. Diese Schnittstelle wird von den Änderungen nicht tangiert. Die neue Schnittstelle umfasst sowohl die neuen, als auch alle alten, weiterhin gewünschten, Funktionen. Sie ist über die URL

\begin{lstlisting}[language=Ruby]
https://meinservice.tld/api/v2/eineRoute
\end{lstlisting}

anzusprechen. Nach Deploy dieser neuen Service Version, wird als nächstes der konsumierende Code geupdated. Hierbei wird die Nutzung der Funktionen auf die neue Version aktualisiert und die Request auf die neue URL umgeleitet. Alle Referenzen zur alten Route des konsumierten Services sollten hierbei entfernt werden. Abschließend kann, solange sichergestellt ist, dass die alte Service Version nicht mehr genutzt wird, der Service ein weiteres mal geupdated werden. Hierbei wird der Code der alten Version entfernt. Dies ist in der Regel nur bei firmeninternen APIs üblich. Externe APIs sollten in veralteten Versionen noch eine gewisse Zeit angeboten werden. Sollte in der neuen API Version ein Fehler auftreten, muss, vorausgesetzt v1 ist unverändert zu erreichen, nur der konsumierende Service gerollbacked werden. Datenbankmigrationen müssen hier nach dem gleichen Prinzip ebenso in mehreren Schritten durchgeführt werden. Das deployment kann also in vielen Fällen bei Microservices leichter sein, gestaltet sich bei großen Änderungen jedoch schwieriger.

In diesem Zug sollte auch das Thema Testing angesprochen werden. Testen, gerade über die Grenzen von Services hinweg, ist durchaus eine Herausforderung die es zu meistern gilt (FIX FORMULIERUNG). Auf der anderen Seite tendieren große monolitische Anwendungen dazu, eine lange Testlaufzeit zu haben. Ab einer gewissen Größe ist es kaum noch möglich, dass der Entwickler alle Tests lokal ausführt. Der Einsatz von Continuous Integration schafft hier natürlich Abhilfe, doch auch hier sind die Ressourcen nicht unbegrenzt. Bei einer Vielzahl von Entwicklern, die parallel arbeiten, können auch mit mehreren concurrent builds Buildstaus oft nicht vermieden werden. Separate Codebases mit separaten kleineren Tests, haben hier vor Allem den großen Vorteil, dass nicht alle Tests immer erneut ausgeführt werden müssen.

Somit verhält sich die Gesamttestlaufzeit t stark unterschiedlich. Die Parallelität des Continuous Integration Servers vernachlässigend, berechnet sich die Gesamtlaufzeit der Tests wie folgt:

$ t = \displaystyle\sum_{i=1}^{noOfCommits} Tt(codebase_i) $

Die Gesamttestlaufzeit berechnet sich demnach additiv aus den Einzeltestlaufzeiten (Tt) der jeweiligen Codebases. Da die Einzeltestlaufzeit bei Microserices wesentlich geringer ist, kann hier enorm an Zeit gespart werden.

Bei vier Entwicklern und einer monolithischen Testlaufzeit von zehn Minuten erreicht man eine Gesamttestdauer von 40 Minuten

$ t = \displaystyle\sum_{i=1}^{4} Tt(codebase_i) = 10m + 10m + 10m + 10m = 40m $

Bei identischer Codebase, beliebig verteilt auf vier Microservices mit identischer Gesamttestdauer von zehn Minuten, erreicht man jedoch nur eine Testdauer von zehn Minuten 

$ t = \displaystyle\sum_{i=1}^{4} Tt(codebase_i) = 3m + 4m + 1m + 2m = 10m $

Natürlich muss man zu der reinen Testdauer der Codebase einen gewissen Overhead im CI System einplanen, der nicht proportional zur Testdauer ist, dieser ist aber für die Ergebnisse zu vernachlässigen. Ebenso sollte die Zahl von Testfällen bei Microservice Architektur etwas erhöht sein, aber auch dies sollte im Vergleich zu einer großen monolithischen Anwendung noch zu einer großen Ersparnis führen.

Separate Services ermöglichen auch, komplett verschiedene (FIX DIVERSE?) Technologiestacks einzusetzen. Im Gegensatz zur Erweiterung einer monolithischen Anwendung, muss hier theoretisch nur bedingt auf die bereits eingesetzten Technologien geachtet werden. Ein separater Service mit separater Datenbank kann durchaus eine andere Datenbanktechnologie verwenden. Da über den separaten Service ohnehin ein separates Datenbankadapter implementiert werden muss, ist es aus reiner Implementierungssicht nicht nachteilig eine andere Datenbanktechnologie zu wählen. Hierbei kann durchaus auf die für den Anwendungsfall spezifischen Optimierungsmöglichkeiten geachtet werden. Ebenso kann eine für den Anwendungsfall optimierte Programmiersprache gewählt werden.
Das diese diverse (FIX ENGLISCH DIVERSE) Technologiewahl aus technischer Sicht möglich und ratsam ist, heißt jedoch keineswegs, dass sie tatsächlich so gewählt werden sollte. Die bestehenden Technologien in einem Unternehmen, welches beschließt eine große, bestehende Anwendung in Microservices aufzuteilen oder um einen Microservice zu erweitern, sind in der Regel tried and tested. Eine Vielzahl der Entwickler des Unternehmens wird mit den bestehenden Technologien vertraut sein. Fällt ein Entwickler aus, sind vermutlich noch genug andere Entwickler mit ähnlichen Fähigkeiten vorhanden um in dringenden Fällen die Arbeit zu übernehmen. Wählt man nun aber eine neue Programmiersprache, eine neue Datenbanktechnologie und neue Monitoring Tools aus, so ist dies ggf. nicht nur mit erhöhter Einarbeitungszeit verbunden, sondern auch mit höheren Managementkosten. Müssen neu eingstellte Entwickler nun den gesamten Technologiestack beherrschen oder nur einen der zwei Teile? Sind immer ausreichend Entwickler vorhanden um einen ausfallenden Entwickler zu kompensieren? Was passiert wenn der Entwickler des neuen Go Microservices kündigt und kein anderer Entwickler Go beherrscht? Die technologische Heterogenität kommt demnach zu einem Preis. Man sollte genau abwägen, bis zu welchem Grad die Diversifizierung des Technologiestacks lohnenswert ist.~\footcite[vgl.][Seiten 5, 6]{newman2015building}
Die Definition eines klaren, ``erforderten Standards''~\footcite[vgl.][Seiten 20, 21]{newman2015building} bietet sich hierzu an. Twitter und Netflix limitieren hierzu z.B. auf Technologien die unter der Java Virtual Machine (JVM) laufen (FIX FORMULIERUNG).~\footcite[][Seite 6]{newman2015building} Entwickler können so eine neue Programmiersprache wie Scala oder JRuby wählen, es wird jedoch auf bekannte Technologien im Betrieb des Servers gesetzt. Dieser erforderte Standard bezieht sich auch auf die gewählten Wekzeuge zum Monitoring und die eingesetzten Schnittstellentechnologien.~\footcite[vgl.][Seite 21]{newman2015building}

Weiterhin ermöglichen separate Services auch das separate Skalieren der Anwendung. Bei Monolithen beschränkt sich die Skalierung im Allgemeinen auf Load Balancing~\footcite[vgl.][]{infaktuell}. Hierzu wird eine Anwendung auf mehrere Server dupliziert, die Anwendungsreplikationen sind hierbei funktional identisch. Ein Load Balancer verteilt dann, nach bestimmten Regeln, die ankommenden Requests auf verschiedene Server.~\footcite[vgl.][]{loadbalancing} Diese verteilte Last ist jedoch unabhängig von den einzelnen Anwendungsteilen. Diese können eine unterschiedliche Individuallast haben, dies kann jedoch über den Load Balancer nicht beachtet werden.
Bei Microservices hingegen kann mintuiöser skaliert werden (fn ANHANG QUELLE)... (FIX AUSBAUEN)

Einzelne Services bedeuten aber nicht nur die Möglichkeit von granulärer Kontrolle, sondern auch die Pflicht der separaten Überwachung. Wo monolithische Anwendungen eine Quelle von Metriken, eine Anwendung zu überwachen und eine Anwendung zu deployen haben, haben Microservices viele.~\footcite[vgl.][]{Heroku:GoMicro}

Weiterhin kommt die Verteilung von Services mit ihren ganz eigenen Kosten. Verteilte Systeme haben den direkten Nachteil, das sie verteilt sind.~\footcite[][]{microtradeoffs} Zwar haben wir klar getrennte Systeme, die von der Codebase her gut zu managen sind, remote calls sind aber immer fehlerbehaftet. Der Service kann down sein, die Antwort zu lange dauern und zu einem Timeout führen und dauern im Allgemeinen länger als code calls. Timeouts und langsame Serviceantworten können natürlich über asynchrone Aufrufe gelöst werden, aber asynchrone Aufrufe bringen ihre eigenen Probleme mit sich. Nicht umsonst spricht man hier oft von der Callback-Hell.~\footcite[vgl.][]{callbackhell} Zweifelsohne kann man Die Callback-Hell vermeiden, die Integration einer Netzwerkschnittstelle in die Codebase birgt aber immer Gefahren. Man kann schlichtweg nicht von einem sicheren Netztwerk ausgehen, demnach bedarf es einem Sicherheitsmechanismus zur Authentifizierung. Bandbreite kann ggf. mit Kosten verbunden sein und ist nicht unbegrenzt verfügbar, das Netztwerk kann fehlerbehaftet sein (FIX RELIABILITY).~\footcite[vgl.][]{distributedfallacies}

Zu guter Letzt sollte man die reine Entwicklungszeit betrachten. Zwar ist die separate Codebase im Nachhinein ggf. leichter zu verwalten, die initiale Entwicklung ist aber durchaus mit einem gewissen Mehraufwand verbunden. Die Wahl der optimalen Technologien ist mit Recherche verbunden, der Einsatz neue Technologien darüber hinaus mit einer Einarbeitungszeit. Das initiale Setup von Programmiersprache, Framework und Datenbank ist ein zusätzlicher Aufwand, der bei der Erweiterung einer bestehenden Codebase nicht anfällt. Hinzu kommt außerdem die Einrichtung des Deployments. Git, Continuous Integration / Deployment, Servereinrichtung, sowie das Monitoren und Warten der Server sind vor allem zum Beginn des Lebenszyklus eines neuen Microservices ein nicht unerheblicher Mehraufwand. Dies und andere Herausforderungen gegen die Potentiale der Microservice Architektur abzuwägen, muss im konkreten Einzelfall immer individuell geschehen.

\section{Der Weg zum Microservice}
Wie eine Anwendung, bestehend aus verschiedenen Microservices, entsteht und entwickelt wird, hängt von der konkreten Ausgangssituation ab. Hier kann man in verschiedenen Situationen unterscheiden:
\begin{description}
  \item[Aufsplittung] \hfill \\
  Ein bereits bestehender Anwendungsteil soll zu einem Microservice umgebaut werden. Der bestehende Code soll nicht ersetzt, sondern lediglich verschoben werden. Die Schnittstellen zum bestehenden Code müssen erneuert werden.
  \item[Rewrite] \hfill \\
  Ein bereits bestehender Anwendungsteil soll von Grund auf neu geschrieben werden. Bestehender Code wird ersetzt und der neue Code als separeter Service in die bestehende Anwendung integriert.
  \item[Erweiterung] \hfill \\
  Ein neuer Anwendungsteil soll entwickelt werden. Die Aufgaben des neuen Anwendungsteils sind weder in der bestehenden Anwendung, noch extern vorhanden. Es wird neuer Code geschrieben und in die bestehende Anwendung integriert.
\end{description}
Zwar unterscheiden sich die drei aufgeführten Ausgangssituationen im Endprodukt nicht zwangsläufig. In der Entwicklung des Microservices muss aber grundlegend anders vorgegangen werden. 

Der erste und zweite Fall unterscheiden sich nicht grundlegend. Die bestehende Schnittstelle zur betroffenen Funktion muss komplett überarbeitet werden. Sowohl in der bestehenden, als auch in der neu entstehenden Anwendung muss diese Schnittstelle geschaffen werden. Auch wenn nur existierender Code verschoben wird, muss eine komplett neue Schnittstelle geschaffen werden. Wo vorher code calls genutzt wurden, werden nun API calls genutzt.
Welches dieser zwei Vorgehensweisen mit mehr Aufwand verbunden ist, hängt zum Großteil von der Komplexität und Struktur der bestehenden Anwendung ab. Auch wie modular der bereits existierende Code ist, ist entscheidend. Je nach Alter des bestehenden Codes ist eine Neuentwicklung teils ratsam. Da die Umarbeitung ohnehin mit erheblichem Arbeitsaufwand verbunden ist, bietet sich eine Optimierung des bestehenden Codes häufig an. Bei großen, komplexen Legacy Anwendungen ist dies in der Praxis aber häufig nicht ratsam.
Bei der Aufsplittung des Monolithen bietet es sich hierbei an, sich am Saum (seams ~\footcite[vgl.][Seite 29 ff.]{feathers2004working}) orientiert werden. Codeteile, die isoliert sind und ohne Seiteneffekte geändert werden können, eignen sich besonders gut um in separate Services verschoben zu werden. Natürlich ist es alles eine Frage der konkreten Problematik, ob ein Service frei, neu gewählt werden kann oder aus Notwendigkeit, unabhängig vom Grad der Komplexität, geschaffen werden muss.

Im dritten Fall kann der neue Anwendungsteil nach idealen und neuen Vorstellungen entwickelt werden. Zwar muss auch hier eine Integration zum bestehenden Code geschaffen werden, es gibt aber keine bisherige Implementation die beachtet werden muss. Die Entwickler haben die freie Wahl, die bestmögliche Integrationsform zu wählen. Dies kann häufig zum besten Endprodukt führen, da keine Einschränkungen durch bestehenden Legacy Code die Programmierung beeinträchtigen. Natürlich wird hier aber ein komplett neues Feature entwickelt. Die Konzeption der Architektur, des Codes und die komplett neue Entwicklung können hier mit einem wesentlichen Mehraufwand verbunden sein. Die Integration in die bestehende Anwendung sollte aber in der Regel mit weniger Problemen verbunden sein.