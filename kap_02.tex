\chapter{Microservice Architektur als Weg robuste und skalierbare Anwendungen zu entwickeln}
``Microservice Architektur'' beschreibt einen Stil der Softwareentwicklung, der vor Allem durch die Trennung einer großen Gesamtanwendung, in kleinere, separate Teile gekennzeichnet ist.~\footcite[vgl.][Seite 2]{newman2015building}
Entscheidend für die Microservice Architektur ist im wesentlichen die Abgrenzung zur monolithischen Anwendungsentwicklung.

\section{Microservices als Werkzeug zum Management von Komplexität}
Monolithische Anwendungen bestehen im wesentlichen aus einer einzelnen Einheit~\footcite[vgl.][]{Fowler:Intro}. In einer klassischen drei-Schichten Anwendung (Frontend, Backend, Persistence Layer)~\footcite[vgl.][]{MSDN:TTA} bietet es sich an, die gesamte Logik in einer Anwendung zu verwalten. Dies ist auch der Standardaufbau der meisten Webframeworks. Es gibt eine Schnittstelle zwischen der clientseitigen und der serverseitigen Anwendung, ebenso wie eine Schnittstelle zwischen der serverseitigen Anwendung und der Datenbank. Unabhängig wie unübersichtlich ein System mit zunehmender Größe wird, das zusammenhalten dieser Anwendungsteile ist der default Weg. Der Hauptgrund für die Entstehung schwer zu handhabender Monolithen ist somit meistens das Wachstum mit der Zeit~\footcite[vgl.][]{infaktuell}.

Anstatt einer großen Anwendung, deren einzelne Teile gemeinsam deployt werden, in einem gemeinsamen repository liegen und auf der Ebene der genutzten Programmiersprache kommunizieren, wird bei der Microservice Architektur die Gesamtanwendung hingegen in einzelne Teilanwendungen aufgesplittet. Diese liegen in separaten Repositories, können getrennt voneinander deployt werden und kommunizieren über externe Schnittstellen. Diese separaten Teilanwendungen sind meist anhand von Aufgabengebieten getrennt und identifiziert. Die Trennung nach Single Responsibility Principle~\footcite[vgl.][Seite 108]{Martin:SRP} wird hier von der Ebene des Codes in die Ebene der Gesamtarchitektur gehoben.

Die Aufteilung einer monolithischen Gesamtanwendung in kleinere Services ist keineswegs ein Allheilmittel für alle Probleme. Microservice Architektur bringt seine ganz eigenen Herausforderungen mit sich. Microservice Architektur bringt demnach vor allem Unterschiede mit sich. Die Frage ob sich diese positiv oder negativ auswirken, hängt ganz individuell von der bestehenden Anwendung, dem Entwicklerteam und den vorhandenen Resourcen ab.

Durch diese Aufteilung in einzelne Teilanwendungen werden jedoch Komplexitäten keineswegs reduziert. Der entstehende Overhead zur Verwaltung verschiedener Codebases, standardisierter Schnittstellen, separater Deploys und separatem Monitoring erzeugt zunächst einmal einen größeren Aufwand. Stattdessen bieten Microservices jedoch viele Optimierungsmöglichkeiten.

\section{Herausforderungen und Potentiale von Microservices}
Wie jeder Architekturstil bieten auch Microservices sowohl Vorzüge, als auch ganz eigene Kosten.~\footcite[vgl.][]{Fowler:Guide} 
Klar strukturierte Codebases verschaffen einen besseren Überblick, sodass sich Entwickler leichter in ein Aufgabe einarbeiten können ohne sich durch irrelevante Codeteile arbeiten zu müssen. Gerade in größeren Teams ist dies von großem Vorteil. Je mehr parallel an voneinander abhängigen Codeteilen gearbeitet wird, desto mehr merge Konflikte entstehen. Auch wenn die eigentlichen Aufgabene komplett voneinander getrennt sind, kommt es häufig zu Konflikten je vermischter der Code ist. Ähnlich wie das Single Responsibility Principle auf Methoden- oder Klassenebene gilt, so gilt es auch auf Service Ebene. Getrennte, klar strukturierte Codeteile erhöhen die Wiederverwendbarkeit, erleichtern die Einarbeitung und das Management des Codes. Ebenso können Änderungen leichter eingearbeitet werden, da die Chance Seiteneffekten reduziert ist. Komplexitäten werden demnach nicht per sé reduziert, sie werden jedoch aufgetrennt und verschoben. Somit werden sie leichter zu handhaben.
So lassen sich zum Einen kleinere, autonome Anwendungsteile aus Entwicklersicht besser verwalten. Die einzelnen Anwendungsteile müssen aber über eine standardisierte Schnittstelle kommunizieren. Diese Aufrufe, die in der Regel über das Intra- oder Internet stattfinden sind in der Regel aufwändiger als simple Code Calls. Wie diese API calls stattfinden ist nicht zwangsläufig vorgeschrieben [WAS FUR MOGLICHKEITEN GIBT ES]. Im Allgemeinen gilt jedoch: Verteilte Systeme sind schwieriger zu programmieren, da remote calls langsam und fehleranfälliger sind.~\footcite[vgl.][]{Fowler:Guide}

Die Aufteilung in separate Services kann ebenso das Deployment vereinfachen. Relative kleine Änderungen können leichter deployt werden, da nicht das ganze System erneut deployt werden muss. Bei großen, komplexen Anwendungen kann dies ein ganz eigenes Risiko bilden. Ist das Deployment einer Anwendung riskoreich, wird dies im Allgemeinen seltener durchgeführt. Features werden erst später deployt, doch mit wachsenden Unterschieden zwischen Deployments, wächst auch das Risiko von Fehlern.~\footcite[vgl.][Seite 6]{newman2015building} Separate Deploys machen die Versionsverwaltung von Services jedoch um so wichtiger~\footcite[vgl.][Seite 62]{newman2015building}~\footcite[vgl.][]{Vergleichsartikel}. Breaking Changes können nicht einfach deployt werden und da prallele Deploys verschiedener kommunizierender Services nicht möglich sind, müssen diese Deploys schrittweise und kontrolliert durchgeführt werden: Zunächst muss der Service um eine neue Version erweitert werden, die alte Schnittstelle darf hierbei nicht verändert werden. Meist werden hierzu API Versionen genutzt. So kann die erste Schnittstelle über die URL

\begin{lstlisting}[language=Ruby]
https://meinservice.tld/api/v1/eineRoute
\end{lstlisting}

angesprochen werden. Diese Schnittstelle wird von den Änderungen nicht tangiert. Die neue Schnittstelle umfasst sowohl die neuen, als auch alle alten Funktionen. Sie ist über die URL

\begin{lstlisting}[language=Ruby]
https://meinservice.tld/api/v2/eineRoute
\end{lstlisting}

anzusprechen. Nach Deploy dieser neuen Service Version, wird als nächstes der konsumierende Code geupdated. Hierbei wird die Nutzung der Funktionen auf die neue Version aktualisiert und die Request auf die neue URL umgeleitet. Alle Referenzen zur alten Route des konsumierten Services sollten hierbei entfernt werden. Abschließen kann, solange sichergestellt ist, dass die alte Service Version nicht mehr genutzt wird, der Service ein weiteres mal geupdated werden. Hierbei wird der Code der alten Version entfernt. Dies ist in der Regel nur bei firmeninternen APIs üblich. Externe APIs sollten in veralteten Versionen noch eine gewisse Zeit angeboten werden. Sollte in der neuen API Version ein Fehler auftreten, muss, vorausgesetzt v1 ist unverändert zu erreich, nur der konsumierende Service gerollbacked werden. Datenbankmigrationen müssen hier nach dem gleichen Prinzip ebenso in mehreren Schritten durchgeführt werden. Das deployment kann also in vielen Fällen bei Microservices leichter sein, sich bei großen Änderungen aber ggf. auch schwierig gestalten.

Separate Services ermöglichen auch, komplett verschiedene (FIX DIVERSE?) Technologiestacks einzusetzen. Im Gegensatz zur Erweiterung einer monolithischen Anwendung, muss hier theoretisch nur bedingt auf die bereits eingesetzten Technologien geachtet werden. Ein separater Service mit separater Datenbank kann durchaus eine andere Datenbanktechnologie verwenden. Da über den separaten Service ohnehin ein separates Datenbankadapter implementiert werden muss, ist es aus reiner Implementierungssicht nicht nachteilig eine andere Datenbanktechnologie zu wählen. Hierbei kann durchaus auf die für den Anwendungsfall spezifischen Optimierungsmöglichkeiten geachtet werden. Ebenso kann eine für den Anwendungsfall optimierte Programmiersprache gewählt werden.
Das diese diverse (FIX ENGLISCH DIVERSE) Technologiewahl aus technischer Sicht möglich und ratsam ist, heißt jedoch keineswegs, dass sie tatsächlich so gewählt werden sollte. Die bestehenden Technologien in einem Unternehmen, welches beschließt eine große, bestehende in Microservices aufzuteilen oder um einen Microservice zu erweitern, sind in der Regel tried and tested. Eine Vielzahl der Entwickler des Unternehmens wird mit den bestehenden Technologien vertraut sein. Fällt ein Entwickler aus, sind vermutlich noch genug andere Entwickler mit ähnlichen Fähigkeiten vorhanden um in dringenden Fällen die Arbeit zu übernehmen. Wählt man nun aber eine neue Programmiersprache, eine neue Datenbanktechnologie und neue Monitoring Tools aus, so ist dies ggf. nicht nur mit erhöhter Einarbeitungszeit verbunden, sondern auch mit höheren Managementkosten. Müssen neu eingstellte Entwickler nun den gesamten Technologiestack beherrschen oder nur einen der zwei Teile? Sind immer ausreichend Entwickler vorhanden um einen ausfallenden Entwickler zu kompensieren? Was passiert wenn der Entwickler des neuen Go Microservices kündigt und kein anderer Entwickler Go beherrscht? Die technologische Heterogenität kommt demnach zu einem Preis. Man sollte genau abwägen, bis zu welchem Grad die Diversifizierung des Technologiestacks lohnenswert ist.~\footcite[vgl.][Seiten 5, 6]{newman2015building}
Die Definition eines klaren, "erforderten Standards"~\footcite[vgl.][Seiten 20, 21]{newman2015building} bietet sich hierzu an. Twitter und Netflix limitieren hierzu z.B. auf Technologien die unter der Java Virtual Machine (JVM) laufen (FIX FORMULIERUNG).~\footcite[][Seite 6]{newman2015building} Entwickler können so eine neue Programmiersprache wählen, es wird jedoch auf bekannte Technologien im Betrieb gesetzt. Dieser erforderte Standard bezieht sich auch auf die gewählten Wekzeuge zum Monitoring und die eingesetzten Schnittstellentechnologien.~\footcite[vgl.][Seite 21]{newman2015building}

Weiterhin ermöglichen separate Services auch das separate Skalieren der Anwendung. Bei Monolithen beschränkt sich die Skalierung im Allgemeinen auf Load Balancing~\footcite[vgl.][]{infaktuell}. Hierzu wird eine Anwendung auf mehrere Server dupliziert, die Anwendungsreplikation sind hierbei funktional identisch. Ein Load Balancer verteilt dann, nach bestimmten Regeln, die ankommenden Requests auf verschiedene Server.~\footcite[vgl.][]{loadbalancing} Diese verteilte Last ist jedoch unabhängig von den einzelnen Anwendungsteilen. Diese können eine unterschiedliche Individuallast haben, dies kann jedoch über den Load Balancer nicht betrachtet werden. 
Bei Microservices hingegen kann mintuiöser skaliert werden (fn ANHANG QUELLE)...

Einzelne Services bedeuten aber nicht nur die Möglichkeit von granulärer Kontrolle, sondern auch die Pflicht der separaten Überwachung. Wo monolithische Anwendungen eine Quelle von Metriken, eine Anwendung zu überwachen und eine Anwendung zu deployen haben, haben Microservices viele~\footcite[vgl.][]{Heroku:GoMicro}.

\section{Der Weg zum Microservice}
Wie eine Anwendung, bestehend aus verschiedenen Microservices, entsteht und entwickelt wird , hängt von der konkreten Ausgangssituation ab. Hier kann man in verschiedenen Situationen unterscheiden:

1. Es neuer Anwendungsteil soll entwickelt werden. Die Aufgaben des neuen Anwendungsteils sind weder in der bestehenden Anwendung, noch extern vorhanden. Es wird neuer Code geschrieben und in die bestehende Anwendung integriert.

2. Ein bereits bestehender Anwendungsteil soll von Grund auf neu geschrieben werden. Bestehender Code wird ersetzt und der neue Code in die bestehende Anwendung integriert.

3. Ein bereits bestehender Anwendungsteil soll zu einem Microservice umgebaut werden. Der bestehende Code soll nicht ersetzt, sondern lediglich verschoben werden. Die Schnittstellen zum bestehenden Code müssen erneuert werden.

Zwar unterscheiden sich die drei aufgeführten Ausgangssituationen im Endprodukt nicht zwangsläufig. In der Entwicklung des Microservices muss aber grundlegend anders vorgegangen werden. 

Im ersten Fall kann der neue Anwendungsteil nach idealen und neuen Vorstellungen entwickelt werden. Zwar muss auch hier eine Integration zum bestehenden Code geschaffen werden, es gibt aber keine bisherige Implementation die beachtet werden muss. Die Entwickler haben die freie Wahl, die bestmögliche Integrationsform zu wählen.

Der zweite und dritte Fall unterscheiden sich nicht grundlegend. Die bestehende Schnittstelle zur betroffenen Funktion muss komplett überarbeitet werden. Sowohl in der bestehenden, als auch in der neu entstehenden Anwendung muss diese Schnittstelle geschaffen werden. Auch wenn nur existierender Code verschoben wird muss in der Regel eine komplett neue Schnittstelle geschaffen werden. Wo vorher code calls genutzt wurden, werden nun API calls genutzt. 
Je nach Komplexität und Struktur der Anwendung kann der zweite oder der dritte Fall in der Umsetzung schwieriger sein. Je nach Alter des bestehenden Codes ist eine Neuentwicklung teils ratsam. Da die Umarbeitung ohnehin mit erheblichem Arbeitsaufwand verbunden ist, bietet sich eine Optimierung des bestehenden Codes häufig an. Bei großen, komplexen Legacy Anwendungen ist dies in der Praxis aber häufig nicht ratsam.
