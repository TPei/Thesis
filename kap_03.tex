\chapter{Entwicklung einer real-time Query Anwendung zur Beschleunigung von Userprofilqueries}
Ein wesentlicher Bestandteil der bestehenden Betriebsanwendung bildet das Abfragen von Userprofildaten. Um für Umfragen passgenau Teilnehmer auszuwählen, gibt es in der Profildatenbank, die knapp 400.000 Nutzer umfasst, 176 Profilfelder. Diese können in allen denkbaren Kombinationen abgefragt werden. Die besteheden Datenbankabfragen geschehen aufgrund ihrer langen Laufzeit asynchron. Hier soll eine neue, synchrone Schnittstelle geschaffen werden.

\section{Real-time Anforderungen erzwingen eine neue Entwicklung}
Das das Finden von Umfrageteilnehmern und demnach das Abfragen der Profilfelder einen wesentlichen Kern der Betriebsanwendung bildet, besteht dieser Teil der Anwendung mit am längsten. In den fast 3 1/2 Jahren ist sowohl die Anzahl der User, also auch die Anzahl der Profilfelder enorm gewachsen, weitaus mehr als initial erwartet. Im Laufe der Zeit stellte sich heraus, das die gewählte Datenbanktechnologie MongoDB, das gewählte ``Schema'' (FIX NO SCHEMA!) und die Art wie gequeried wird, nicht optimal und daher nicht schnell genug sind. Da das Abfragen der Profilfelder wesentlichster Bestandteil des Kerngeschäfts ist und die Defizite die Situation mit wachsender User- und Kundenzahl nur verschärfen, wurde deutlich, dass eine Überarbeitung der bestehenden Strukturen notwendig ist.

\section{Majestic Monolith vs Minimal Microservice}
Um die Probleme zu lösen kann auf vielerlei Wege vorgegangen werden. Eine neue Datenbanktechnologie mit optimiertem Schema kann gewählt werden, der Code kann auf Geschwindigkeit optimiert oder komplett neu geschrieben werden.
Die hier eingesetzte Datenbank MongoDB wird noch für weitere Funktionen in der Anwendung genutzt und kann daher nicht komplett ersetzt werden. Eine bestehende MySQL Datenbank ist bereits als Datawarehouse im Einsatz und erfährt bereits load.
Die bestehende Anwendung ist mit den Jahren allgemein recht groß und unhandlich geworden.
Eine Aufsplittung der Anwenung in mehrere Teile, mit Hilfe der Microservice Architektur, wurde beschlossen.
Mit Hilfe der Microservice Architektur können hier Probleme der Skalierung, Optimierung der Datenbanktechnologie, Beschleunigung des Codes und Schaffung von Ordnung im Code angegangen werden.
Da eine neue Datenbanktechnologie und ein komplett separater Service ohnehin mit vielen Änderungen verbunden ist, wurde beschlossen den alten Code nicht in einen neuen Service zu migrieren, sondern die Funktionalität neu zu Schaffen.

\section{Mit dem Strangler Pattern vom Monolithen zur Microservice Architektur}
Da die aktuelle Arbeitslage, die vorhandenen Entwickler und die Größe der Anwendung es nicht zulassen diese direkt komplett zu überarbeiten, wird hier die Architektur mit Hilfe des Strangler Patterns~\footcite[][]{Fowler:Strangler} Schritt für Schritt umgesetzt.
Statt traditionellem Load Balancer, wird hier mit Hilfe des Ruby Flipper Gems~\footnote{https://github.com/jnunemaker/flipper} nach und nach mehr Last auf den neu entstehenden Service verteilt.~\footcite[vgl.][]{Hammant:Strangler}