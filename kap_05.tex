\chapter{Microservice Architektur als Pattern der Zukunft?}

Die Frage, ob Microservice Architektur im Betrieb eingesetzt werden sollte, lässt sich pauschal schlichtweg nicht beantworten. Die Voraussetzungen um erfolgreich zu einer Microservice Architektur zu wechseln, sind individuell und vor Allem von der bestehenden Anwendung und den Teamgegebenheiten abhängig. Microservices können dabei Helfen viele Probleme des klassischen monolithischen Anwendungsentwicklung, insbesondere eine große, unübersichtliche Codebase, Performance Probleme, hohe Kosten und unklare Strukturen, zu lösen. Jedoch setzt der Einsatz vieles Voraus, dessen Aufbau ein langwieriger Prozess sein kann. Eine Teamstruktur, in denen sich Entwickler selbst für den Betrieb der von ihnen entwickelten Anwendung verantwortlich sehen, dynamische Serverstrukturen  zum Skalieren der Services wie sie z.B. AWS, Google Compute Engine und Heroku bieten, automatisierte Deploys und ausgereifte Monitoring Lösungen sind für den erfolgreichen und sinnvollen Einsatz von Microservices unabdingbar.

Sollten Microservices nicht direkt zu Beginn des Softwarelebenszyklus entstehen, ist es wichtig den Übergang so kontrolliert wie möglich zu schaffen. Die Microservice Architektur stellt sicherlich keine schnelle Lösung für Probleme im Betrieb dar. Stattdessen ist sie eine längerfristige Strategie um die Organisation und Arbeit in der Firma zu verbessern.\cite{newman2015building} Wird eine bestehende Anwendung zu einer Microservice Architektur umgewandelt, so bietet es sich zum Beispiel an, neu entstehende Software Teile als Microservices zu entwickeln, um so die Codebase nicht noch weiter wachsen zu lassen. Auch besteht die Möglichkeit einen neuen Service zunächst an den bestehenden Hauptservice zu koppeln. Das ``große'' Framework Ruby on Rails bietet so z.B. die Möglichkeit, mit dem Microframework Sinatra entwickelte Apps in der Hauptanwendung zu \textit{mounten}. Hierdurch erhält die Subanwendung einen relativen Pfad in der Hauptanwendung und kann so wie über interne Routen angesprochen werden. Die Subanwendung kann dann mit der Hauptanwendung deployt und betrieben werden. Hierdurch können viele der initialen Herausforderungen von Microservices, wie das Monitoring, der separate Betrieb und die dynamische Skalierung der Anwendung, umgangen werden, jedoch einige der Vorzüge, wie separate Codebases und klare Strukturen bereits genutzt werden. Ebenso können hier dann z.B. auch queueing-Dienste wie Sidekiq als Kommunikationsschnittstelle dienen.~\cite[vgl.][]{sidekiqmessaging} Dies erspart zunächst die Entwicklung einer vollwertigen API. Nach Aufbau geeigneter Firmenstrukturen kann die Anwendung dann mit verhältnismäßig geringem Aufwand zu einem vollwertigen Microservice ausgebaut werden. So ist man zeitlich bei der Programmierung eines Microservices nicht an dessen unmittelbaren Betrieb als solcher gebunden.

In der hier entwickelten Anwendung wurde vor allem beim Ersetzen der bestehenden Anwendungsteile durch den Microservice auf eine kontrollierte Integration geachtet. Durch Feature Toggles wurden zunächst im Betrieb nur bestimmte, explizit gewählte Queries an den Microservice gesendet. Später können dann schrittweise einzelne User freigeschaltet und prozentual, langsam eine immer höhere Zahl an Queries an den Microservice umgelagert werden. So kann nach Testen und Sicherstellen der Funktion langsam immer mehr Last auf den Microservice verschoben und so die Chance einer Überlastung und anderer unerwarteter Fehler minimiert werden.

In der hier umgesetzten praktischen Arbeit kann man den entwickelten Microservice als Erfolg betrachten. Der entwickelte Microservice ist weit mehr als nur ein Prototyp und wird nun aktiv in den Betrieb integriert. Zwar ist die Entwicklung hier noch nicht abgeschlossen und die parallele Anwendung mit der alten Struktur ist durchaus ratsam, die erhofften Performance Verbesserungen durch die Entwicklung der neuen Teilanwendung konnten jedoch erreicht werden. Die Transition, wenn auch noch nicht komplett abgeschlossen, läuft erfolgreich und die Struktur der Anwendung konnte, vor allem in Augen der betroffenen Entwickler, verbessert werden. Lediglich auf der Seite der Kosten konnte keine Verbesserung erzielt werden. Dies liegt vor allem daran, das der bisherige Hosting Plan keinerlei Dynamik vorsieht und so, trotz sinkender Last, zu keiner Kostenreduzierung führt. Die durch den neuen Service entstehenden Mehrkosten sind aber nicht höher als erwartet und somit stellt auch dies kein Problem dar.

Die Ausarbeitung von neuen Monitoring, Logging und Deploy Lösungen wurde im Rahmen der Arbeit erfolgreich umgesetzt und bereits im Unternehmen erprobt.

Aus Entwicklersicht kann man ebenfalls von einem Erfolg sprechen. Die Entwicklung eines komplett neuen Anwendungsteils ist  angenehmer als eine bestehende, drei Jahre alte Anwendung um einen weiteren Teil zu ergänzen. Es bestehen keine Einschränkungen an die der Entwickler gebunden ist und vor Allem durch die strenge Trennung in einen separaten Service und die Definition von eindeutigen Schnittstellen kann die interne Definition vom Entwickler frei gewählt werden. Die klare Trennung und das Ansprechen über eine REST API machen den Code sauber und gut nachzuvollziehen. In der Zukunft wird es hier möglich sein den neuen Codeteil leicht zu warten, ohne unerwartete Nebeneffekte zu erfahren. Die Einbindung des neuen Services in die bestehende Anwendung stellte sich jedoch als weitaus schwieriger als erwartet heraus. Hier fanden sich genau all die Probleme, die Microservices zu vermeiden hoffen. Durchmischte Schnittstellen mit Seiteneffekten bei Änderungen führten dazu das zeitweise mehrere Hundert Testfehler auftraten. Die Integration, nach vermeintlicher Fertigstellung des Services, dauerte einige Wochen.
Aufgrund der erhöhten Integrationszeit konnte bisher auch kein automatisches Updaten der Daten im Microservice eingerichtet werden. Die Schnittstelle zum Einführen von Userdaten ist jedoch im Microservice fertiggestellt und wurde bereits im Betrieb erprobt. Bisher wurden jedoch nur manuell Daten über die Schnittstelle in \textit{gebatchter} Form in den Microservice übertragen.

Während der Entwicklung des Microservices wurde auch schnell deutlich, dass es sich um einen relativ jungen Architekturstil handelt. Vieles was bei internen Anwendungsteilen keine Rolle spielt, muss hier noch selbst implementiert werden. Zwar bieten Toolkits wie Go kit\cite{gokit} Schnittstellendefinitionen, Circuit Breaker und Rate Limiter, sowie Metrics, Logging und Request Tracing aber auch dieses Projekt ist noch sehr jung und bei weitem keine standardisierte Lösung. Andere Programmiersprachen besitzen zudem teilweise noch keine solchen Toolsets in diesem Bereich.

Die vorliegende Arbeit zeigt, das die Integration in ein bestehendes System möglich ist und auf lange Sicht Vorteile hat, jedoch ist sie auf Kurze Sicht mit nicht unerheblichem Mehraufwand verbunden. Ob die in der Entwicklung entstandenen Mehrkosten jedoch über Zeit eingespart werden können, relativ über leichtere Entwicklungsarbeit dank sauberer Codebase oder durch bessere Performance des Systems, wird sich mit der Zeit zeigen und muss immer im konkreten Einzelfall evaluiert werden.
